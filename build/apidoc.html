<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://csscomb.com/"

    >csscomb (v4.0.1)</a>
</h1>
<h4>CSS coding style formatter</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb">module csscomb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.csscomb">
            function <span class="apidocSignatureSpan"></span>csscomb
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.detectInFile">
            function <span class="apidocSignatureSpan">csscomb.</span>detectInFile
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.detectInString">
            function <span class="apidocSignatureSpan">csscomb.</span>detectInString
            <span class="apidocSignatureSpan">(text, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.getConfig">
            function <span class="apidocSignatureSpan">csscomb.</span>getConfig
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.getCustomConfig">
            function <span class="apidocSignatureSpan">csscomb.</span>getCustomConfig
            <span class="apidocSignatureSpan">(configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.getCustomConfigPath">
            function <span class="apidocSignatureSpan">csscomb.</span>getCustomConfigPath
            <span class="apidocSignatureSpan">(configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.plugin">
            function <span class="apidocSignatureSpan">csscomb.</span>plugin
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>always_semicolon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>block_indent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>color_case</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>color_shorthand</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>element_case</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>eof_newline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>leading_zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>lines_between_rulesets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>plugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>quotes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>remove_empty_rulesets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>sort_order</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>sort_order_fallback</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_after_colon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_after_combinator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_after_opening_brace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_after_selector_delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_before_closing_brace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_before_colon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_before_combinator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_before_opening_brace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_before_selector_delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>space_between_declarations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>strip_spaces</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>tab_size</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.</span>unitless_zero</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.always_semicolon">module csscomb.always_semicolon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.always_semicolon.detect">
            function <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.always_semicolon.lint">
            function <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>lint
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.always_semicolon.process">
            function <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.block_indent">module csscomb.block_indent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.block_indent._processNode">
            function <span class="apidocSignatureSpan">csscomb.block_indent.</span>_processNode
            <span class="apidocSignatureSpan">(node, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.block_indent._processSassBlock">
            function <span class="apidocSignatureSpan">csscomb.block_indent.</span>_processSassBlock
            <span class="apidocSignatureSpan">(node, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.block_indent._processSpaceNode">
            function <span class="apidocSignatureSpan">csscomb.block_indent.</span>_processSpaceNode
            <span class="apidocSignatureSpan">(node, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.block_indent.detect">
            function <span class="apidocSignatureSpan">csscomb.block_indent.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.block_indent.process">
            function <span class="apidocSignatureSpan">csscomb.block_indent.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.block_indent.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.block_indent.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.block_indent.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.block_indent.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.color_case">module csscomb.color_case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.color_case.detect">
            function <span class="apidocSignatureSpan">csscomb.color_case.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.color_case.process">
            function <span class="apidocSignatureSpan">csscomb.color_case.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.color_case.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.color_case.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.color_case.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.color_shorthand">module csscomb.color_shorthand</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.color_shorthand.detect">
            function <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.color_shorthand.process">
            function <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.element_case">module csscomb.element_case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.element_case.detect">
            function <span class="apidocSignatureSpan">csscomb.element_case.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.element_case.process">
            function <span class="apidocSignatureSpan">csscomb.element_case.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.element_case.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.element_case.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.element_case.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.eof_newline">module csscomb.eof_newline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.eof_newline.detect">
            function <span class="apidocSignatureSpan">csscomb.eof_newline.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.eof_newline.process">
            function <span class="apidocSignatureSpan">csscomb.eof_newline.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.eof_newline.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.eof_newline.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.eof_newline.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.errors">module csscomb.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.configParsingError">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>configParsingError
            <span class="apidocSignatureSpan">(configPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.implementSetValue">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>implementSetValue
            <span class="apidocSignatureSpan">(valueType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.missingName">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>missingName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.missingSetValue">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>missingSetValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.missingSyntax">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>missingSyntax
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.missingTemplateFile">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>missingTemplateFile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.twoPluginsWithSameName">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>twoPluginsWithSameName
            <span class="apidocSignatureSpan">(pluginName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.unacceptableBoolean">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableBoolean
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.unacceptableNumber">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.unacceptableString">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableString
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.errors.unacceptableValueType">
            function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableValueType
            <span class="apidocSignatureSpan">(valueType, accepts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.leading_zero">module csscomb.leading_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.leading_zero.detect">
            function <span class="apidocSignatureSpan">csscomb.leading_zero.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.leading_zero.process">
            function <span class="apidocSignatureSpan">csscomb.leading_zero.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.leading_zero.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.leading_zero.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.leading_zero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.lines_between_rulesets">module csscomb.lines_between_rulesets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.buildSpacing">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>buildSpacing
            <span class="apidocSignatureSpan">(syntax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.findLatestNonCommentNode">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>findLatestNonCommentNode
            <span class="apidocSignatureSpan">(parent, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.insertNewlines">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>insertNewlines
            <span class="apidocSignatureSpan">(node, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.insertNewlinesAsNode">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>insertNewlinesAsNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.insertNewlinesAsString">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>insertNewlinesAsString
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.isComment">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>isComment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.isNewline">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>isNewline
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.prevLineIsComment">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>prevLineIsComment
            <span class="apidocSignatureSpan">(parent, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.process">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.processAtRules">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>processAtRules
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.processBlock">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>processBlock
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.processRuleSets">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>processRuleSets
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.lines_between_rulesets.setValue">
            function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>setValue
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>newLinesNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>newLinesString</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.plugin">module csscomb.plugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.plugin.plugin">
            function <span class="apidocSignatureSpan">csscomb.</span>plugin
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.plugin.prototype">module csscomb.plugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.plugin.prototype.validate">
            function <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>lint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>value</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>value_</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.quotes">module csscomb.quotes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.quotes.detect">
            function <span class="apidocSignatureSpan">csscomb.quotes.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.quotes.process">
            function <span class="apidocSignatureSpan">csscomb.quotes.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.quotes.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.quotes.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.quotes.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.remove_empty_rulesets">module csscomb.remove_empty_rulesets</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>detectDefault</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.remove_empty_rulesets.detect">
            function <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.remove_empty_rulesets.process">
            function <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.sort_order">module csscomb.sort_order</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._cleanSassLinebreaks">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_cleanSassLinebreaks
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._extendNode">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_extendNode
            <span class="apidocSignatureSpan">(block, i, spacesBefore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getLastGroupIndex">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getLastGroupIndex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getLastPropertyIndex">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getLastPropertyIndex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getNodesByIndex">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getNodesByIndex
            <span class="apidocSignatureSpan">(block, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getSortableIncludeName">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSortableIncludeName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getSortableName">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSortableName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getSortablePropertyName">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSortablePropertyName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getSpacesAndCommentsAfterNode">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSpacesAndCommentsAfterNode
            <span class="apidocSignatureSpan">(node, i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._getSpacesAndCommentsBeforeNode">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSpacesAndCommentsBeforeNode
            <span class="apidocSignatureSpan">(node, i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._insertSortablesToBlock">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_insertSortablesToBlock
            <span class="apidocSignatureSpan">(nodesToSort, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._isAcceptableNode">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_isAcceptableNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._isSpaceOrComment">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_isSpaceOrComment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._processBlock">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_processBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._removeEmptyLines">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_removeEmptyLines
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._separateSortablesFromBlock">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_separateSortablesFromBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._sortLeftovers">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_sortLeftovers
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order._sortNodes">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_sortNodes
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order.detect">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>detect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order.process">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>process
            <span class="apidocSignatureSpan">(ast, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order.setValue">
            function <span class="apidocSignatureSpan">csscomb.sort_order.</span>setValue
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.sort_order.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.sort_order.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.sort_order.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.sort_order_fallback">module csscomb.sort_order_fallback</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order_fallback.detect">
            function <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>detect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.sort_order_fallback.process">
            function <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>process
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_after_colon">module csscomb.space_after_colon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_colon.detect">
            function <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_colon.process">
            function <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_after_combinator">module csscomb.space_after_combinator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_combinator.detect">
            function <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_combinator.process">
            function <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_after_opening_brace">module csscomb.space_after_opening_brace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_opening_brace.detect">
            function <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_opening_brace.process">
            function <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_after_selector_delimiter">module csscomb.space_after_selector_delimiter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_selector_delimiter.detect">
            function <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_after_selector_delimiter.process">
            function <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_before_closing_brace">module csscomb.space_before_closing_brace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_closing_brace.detect">
            function <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_closing_brace.process">
            function <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>process
            <span class="apidocSignatureSpan">(ast, config)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_before_colon">module csscomb.space_before_colon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_colon.detect">
            function <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_colon.process">
            function <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_before_combinator">module csscomb.space_before_combinator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_combinator.detect">
            function <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_combinator.process">
            function <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_before_opening_brace">module csscomb.space_before_opening_brace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_opening_brace.detect">
            function <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_opening_brace.process">
            function <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_before_selector_delimiter">module csscomb.space_before_selector_delimiter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_selector_delimiter.detect">
            function <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_before_selector_delimiter.process">
            function <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.space_between_declarations">module csscomb.space_between_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.space_between_declarations.process">
            function <span class="apidocSignatureSpan">csscomb.space_between_declarations.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_between_declarations.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.space_between_declarations.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_between_declarations.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.space_between_declarations.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.strip_spaces">module csscomb.strip_spaces</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>detectDefault</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.strip_spaces.detect">
            function <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.strip_spaces.process">
            function <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.tab_size">module csscomb.tab_size</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.tab_size.process">
            function <span class="apidocSignatureSpan">csscomb.tab_size.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.tab_size.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.tab_size.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.tab_size.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.tab_size.</span>runBefore</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csscomb.unitless_zero">module csscomb.unitless_zero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.unitless_zero.detect">
            function <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>detect
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csscomb.unitless_zero.process">
            function <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>process
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>accepts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>name</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb" id="apidoc.module.csscomb">module csscomb</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.csscomb" id="apidoc.element.csscomb.csscomb">
        function <span class="apidocSignatureSpan"></span>csscomb
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">csscomb = function (config) {
  let comb = new Comb();

  // Add plugins.
  fs.readdirSync(__dirname + &#x27;/options&#x27;).map(function (option) {
    return require(&#x27;./options/&#x27; + option);
  }).forEach(function (option) {
    comb.use(option);
  });

  // If config was passed, configure:
  if (typeof config === &#x27;string&#x27;) {
    config = CSScomb.getConfig(config);
  }
  if (typeof config === &#x27;object&#x27;) {
    comb.configure(config);
  }

  // Chaining.
  return comb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.detectInFile" id="apidoc.element.csscomb.detectInFile">
        function <span class="apidocSignatureSpan">csscomb.</span>detectInFile
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function detectInFile(file, options) {
  var stylesheet = fs.readFileSync(file, &#x27;utf8&#x27;);
  return CSScomb.detectInString(stylesheet, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function displayHelp() {
var help = [&#x27;NAME&#x27;, &#x27;    csscomb  Lint and fix style errors in css files&#x27;, &#x27;&#x27;, &#x27;SYNOPSIS&#x27
;, &#x27;    csscomb [options] file.css&#x27;, &#x27;    cat file.css | csscomb [options] -&#x27;, &#x27;&#x27;, &#x27;OPTIONS&#
x27;, &#x27;    -c, --config [path]&#x27;, &#x27;        Path to configuration file.&#x27;, &#x27;    -d, --detect&#x27;, &#x27;
Run the tool in detect mode, returning detected options.&#x27;, &#x27;    -l, --lint&#x27;, &#x27;        Run the tool in linter
 mode, without modifying files.&#x27;, &#x27;    -h, --help&#x27;, &#x27;        Display help message.&#x27;, &#x27;    -v, --verbose
&#x27;, &#x27;        Whether to print logging info.&#x27;];
process.stdout.write(help.join(&#x27;\n&#x27;));
}

function detectConfig() {
const config = Comb.<span class="apidocCodeKeywordSpan">detectInFile</span>(options.detect);
return JSON.stringify(config, false, 4);
}

function getConfig() {
var configPath = options.config &#x26;&#x26; path.resolve(process.cwd(), options.config) || Comb.getCustomConfigPath();

var config;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.detectInString" id="apidoc.element.csscomb.detectInString">
        function <span class="apidocSignatureSpan">csscomb.</span>detectInString
        <span class="apidocSignatureSpan">(text, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function detectInString(text, options) {
  var result;
  var handlers = [];

  if (!text) return text;

  var optionNames = fs.readdirSync(__dirname + &#x27;/options&#x27;);
  optionNames.forEach(function (option) {
    option = option.slice(0, -3);
    if (options &#x26;&#x26; options.indexOf(option) &#x3c; 0) return;
    try {
      handlers.push(getHandler(option));
    } catch (e) {
      let message = `\nFailed to load &#x22;${option}&#x22; option:\n${e.message}`;
      console.warn(message);
    }
  });

  var tree = cssToAST(text);
  var detectedOptions = detectInTree(tree, handlers);
  result = getDetectedOptions(detectedOptions, handlers);

  // Handle conflicting options with spaces around braces:
  var blockIndent = result[&#x27;block-indent&#x27;];
  var spaceAfterOpeningBrace = result[&#x27;space-after-opening-brace&#x27;];

  if (typeof blockIndent === &#x27;string&#x27; &#x26;&#x26; spaceAfterOpeningBrace &#x26;&#x26; spaceAfterOpeningBrace.indexOf(&#x27;\n&#x27;) &#x3e; -1) {
    result[&#x27;space-after-opening-brace&#x27;] = &#x27;\n&#x27;;
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.getConfig" id="apidoc.element.csscomb.getConfig">
        function <span class="apidocSignatureSpan">csscomb.</span>getConfig
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getConfig(name) {
  const DEFAULT_CONFIG_NAME = &#x27;csscomb&#x27;;
  name = name || DEFAULT_CONFIG_NAME;

  if (typeof name !== &#x27;string&#x27;) {
    throw new Error(&#x27;Config name must be a string.&#x27;);
  }

  let CONFIG_DIR_PATH = &#x27;../config&#x27;;
  let dir = `${__dirname}/${CONFIG_DIR_PATH}`;
  let availableConfigsNames = fs.readdirSync(dir).map(function (configFileName) {
    return configFileName.split(&#x27;.&#x27;)[0]; // Strip file extension(s)
  });

  if (availableConfigsNames.indexOf(name) &#x3c; 0) {
    let configsNamesAsString = availableConfigsNames.map(function (configName) {
      return &#x27;\&#x27;&#x27; + configName + &#x27;\&#x27;&#x27;;
    }).join(&#x27;, &#x27;);
    let message = `&#x22;${name}&#x22; is not a valid config name. Try one
                   of the following: ${configsNamesAsString}.`;
    throw new Error(format(message));
  }

  return require(CONFIG_DIR_PATH + &#x27;/&#x27; + name + &#x27;.json&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.getCustomConfig" id="apidoc.element.csscomb.getCustomConfig">
        function <span class="apidocSignatureSpan">csscomb.</span>getCustomConfig
        <span class="apidocSignatureSpan">(configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCustomConfig(configPath) {
  var config;
  configPath = configPath || CSScomb.getCustomConfigPath();

  try {
    config = JSON.parse(fs.readFileSync(configPath, &#x27;utf8&#x27;));
  } catch (e) {
    config = null;
  }

  return config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var config;
if (!fs.existsSync(configPath)) {
  config = require(&#x27;../config/csscomb.json&#x27;);
} else if (configPath.match(/\.css$/)) {
  config = Comb.detectInFile(configPath);
} else {
  config = Comb.<span class="apidocCodeKeywordSpan">getCustomConfig</span>(configPath);
}

if (!config) {
  const errorMessage = Errors.configParsingError(configPath);
  process.stderr.write(errorMessage);
  process.exit(1);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.getCustomConfigPath" id="apidoc.element.csscomb.getCustomConfigPath">
        function <span class="apidocSignatureSpan">csscomb.</span>getCustomConfigPath
        <span class="apidocSignatureSpan">(configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCustomConfigPath(configPath) {
  var HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;

  configPath = configPath || path.join(process.cwd(), &#x27;.csscomb.json&#x27;);

  // If we&#x27;ve finally found a config, return its path:
  if (fs.existsSync(configPath)) return fs.realpathSync(configPath);

  // If we are in HOME dir already and yet no config file, return a default
  // one from our package.
  // If project is located not under HOME, compare to root instead.
  // Since there appears to be no good way to get root path in
  // Windows, assume that if current dir has no parent dir, we&#x27;re in
  // root.
  var dirname = path.dirname(configPath);
  var parentDirname = path.dirname(dirname);
  if (dirname === HOME || dirname === parentDirname) return null;

  // If there is no config in this directory, go one level up and look for
  // a config there:
  configPath = path.join(parentDirname, &#x27;.csscomb.json&#x27;);
  return CSScomb.getCustomConfigPath(configPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function detectConfig() {
const config = Comb.detectInFile(options.detect);
return JSON.stringify(config, false, 4);
}

function getConfig() {
var configPath = options.config &#x26;&#x26; path.resolve(process.cwd(), options.config) || Comb.<span class="apidocCodeKeywordSpan
">getCustomConfigPath</span>();

var config;
if (!fs.existsSync(configPath)) {
  config = require(&#x27;../config/csscomb.json&#x27;);
} else if (configPath.match(/\.css$/)) {
  config = Comb.detectInFile(configPath);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.plugin" id="apidoc.element.csscomb.plugin">
        function <span class="apidocSignatureSpan">csscomb.</span>plugin
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plugin = function (methods) {
  for (let method in methods) {
    this[method] = typeof method === &#x27;function&#x27; ? methods[method].bind(this) : methods[method];
  }

  this.validate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.always_semicolon" id="apidoc.module.csscomb.always_semicolon">module csscomb.always_semicolon</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.always_semicolon.detect" id="apidoc.element.csscomb.always_semicolon.detect">
        function <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect(ast) {
  var detected = [];

  ast.traverseByType(&#x27;block&#x27;, block =&#x3e; {
    block.eachFor(node =&#x3e; {
      if (node.is(&#x27;declarationDelimiter&#x27;)) {
        detected.push(true);
        return null;
      } else if (node.is(&#x27;declaration&#x27;)) {
        detected.push(false);
        return null;
      }
    });
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.always_semicolon.lint" id="apidoc.element.csscomb.always_semicolon.lint">
        function <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>lint
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lint(ast) {
  var errors = [];

  ast.traverseByType(&#x27;block&#x27;, block =&#x3e; {
    block.eachFor(currentNode =&#x3e; {
      var nodeWithoutSemicolon;
      // Skip nodes that already have `;` at the end:
      if (currentNode.is(&#x27;declarationDelimiter&#x27;)) return null;

      // Add semicolon only after declarations and includes.
      // If current node is include, insert semicolon right into it.
      // If it&#x27;s declaration, look for value node:
      if (currentNode.is(&#x27;include&#x27;) || currentNode.is(&#x27;extend&#x27;)) {
        nodeWithoutSemicolon = currentNode;
      } else if (currentNode.is(&#x27;declaration&#x27;)) {
        nodeWithoutSemicolon = currentNode.last(&#x27;value&#x27;);
      } else {
        return;
      }

      errors.push({
        message: &#x27;Missing semicolon&#x27;,
        line: nodeWithoutSemicolon.end.line,
        column: nodeWithoutSemicolon.end.column + 1
      });

      // Stop looping through block&#x27;s children:
      return null;
    });
  });

  return errors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  _lintTree(ast, filename) {
let errors = [];
let config = this.config;

this.plugins.filter(function (plugin) {
  return typeof plugin.value !== null &#x26;&#x26; typeof plugin.lint === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf
(ast.syntax) !== -1;
}).forEach(function (plugin) {
  let e = plugin.<span class="apidocCodeKeywordSpan">lint</span>(ast, config);
  errors = errors.concat(e);
});

if (filename) {
  errors.map(function (error) {
    error.filename = filename;
    return error;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.always_semicolon.process" id="apidoc.element.csscomb.always_semicolon.process">
        function <span class="apidocSignatureSpan">csscomb.always_semicolon.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  var nodeWithoutSemicolon;

  ast.traverseByType(&#x27;block&#x27;, block =&#x3e; {
    block.eachFor(currentNode =&#x3e; {
      // Skip nodes that already have `;` at the end:
      if (currentNode.is(&#x27;declarationDelimiter&#x27;)) return null;

      // Add semicolon only after declarations and includes.
      // If current node is include, insert semicolon right into it.
      // If it&#x27;s declaration, look for value node:
      if (currentNode.is(&#x27;include&#x27;) || currentNode.is(&#x27;extend&#x27;)) {
        nodeWithoutSemicolon = currentNode;
      } else if (currentNode.is(&#x27;declaration&#x27;)) {
        nodeWithoutSemicolon = currentNode.last(&#x27;value&#x27;);
      } else {
        return;
      }

      // Check if there are spaces and comments at the end of the node
      for (var j = nodeWithoutSemicolon.length; j--;) {
        var lastNode = nodeWithoutSemicolon.get(j);

        // If the node&#x27;s last child is block, do not add semicolon:
        // TODO: Add syntax check and run the code only for scss
        if (lastNode.is(&#x27;block&#x27;)) {
          return null;
        } else if (!lastNode.is(&#x27;space&#x27;) &#x26;&#x26; !lastNode.is(&#x27;multilineComment&#x27;) &#x26;&#x26; !lastNode.is(&#x27;singlelineComment&#x27;)) {
          j++;
          break;
        }
      }

      var declDelim = gonzales.createNode({
        type: &#x27;declarationDelimiter&#x27;,
        content: &#x27;;&#x27;
      });
      nodeWithoutSemicolon.insert(j, declDelim);
      return null;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.block_indent" id="apidoc.module.csscomb.block_indent">module csscomb.block_indent</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.block_indent._processNode" id="apidoc.element.csscomb.block_indent._processNode">
        function <span class="apidocSignatureSpan">csscomb.block_indent.</span>_processNode
        <span class="apidocSignatureSpan">(node, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processNode(node, level) {
  var that = this;

  node.forEach(function (n) {
    if (node.syntax === &#x27;sass&#x27; &#x26;&#x26; n.is(&#x27;block&#x27;)) {
      that._processSassBlock(n, level);
    }

    // Continue only with space nodes inside {...}:
    if (node.syntax !== &#x27;sass&#x27; &#x26;&#x26; level !== 0 &#x26;&#x26; n.is(&#x27;space&#x27;)) {
      that._processSpaceNode(n, level);
    }

    if (n.is(&#x27;block&#x27;) || n.is(&#x27;atrulers&#x27;)) level++;

    that._processNode(n, level);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (spaces === &#x27;&#x27;) {
      ast.remove(i);
    } else {
      whitespaceNode.content = spaces;
    }
  });

  this.<span class="apidocCodeKeywordSpan">_processNode</span>(ast, 0);
},

/**
 * Detects the value of this option in ast.
 * @param {Node} ast
 * @return {Array} List of detected values
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.block_indent._processSassBlock" id="apidoc.element.csscomb.block_indent._processSassBlock">
        function <span class="apidocSignatureSpan">csscomb.block_indent.</span>_processSassBlock
        <span class="apidocSignatureSpan">(node, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processSassBlock(node, level) {
  var value = this.value;

  node.eachFor(&#x27;space&#x27;, function (whitespaceNode) {
    if (whitespaceNode.content === &#x27;\n&#x27;) return;

    var spaces = whitespaceNode.content.replace(/[ \t]/gm, &#x27;&#x27;);
    spaces += new Array(level + 2).join(value);
    whitespaceNode.content = spaces;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Number} level
   */
  _processNode(node, level) {
    var that = this;

    node.forEach(function (n) {
if (node.syntax === &#x27;sass&#x27; &#x26;&#x26; n.is(&#x27;block&#x27;)) {
  that.<span class="apidocCodeKeywordSpan">_processSassBlock</span>(n, level);
}

// Continue only with space nodes inside {...}:
if (node.syntax !== &#x27;sass&#x27; &#x26;&#x26; level !== 0 &#x26;&#x26; n.is(&#x27;space&#x27;)) {
  that._processSpaceNode(n, level);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.block_indent._processSpaceNode" id="apidoc.element.csscomb.block_indent._processSpaceNode">
        function <span class="apidocSignatureSpan">csscomb.block_indent.</span>_processSpaceNode
        <span class="apidocSignatureSpan">(node, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processSpaceNode(node, level) {
  var value = this.value;

  // Remove all whitespaces and tabs, leave only new lines:
  var spaces = node.content.replace(/[ \t]/gm, &#x27;&#x27;);

  if (!spaces) return;

  spaces += new Array(level + 1).join(value);
  node.content = spaces;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  node.forEach(function (n) {
    if (node.syntax === &#x27;sass&#x27; &#x26;&#x26; n.is(&#x27;block&#x27;)) {
      that._processSassBlock(n, level);
    }

    // Continue only with space nodes inside {...}:
    if (node.syntax !== &#x27;sass&#x27; &#x26;&#x26; level !== 0 &#x26;&#x26; n.is(&#x27;space&#x27;)) {
      that.<span class="apidocCodeKeywordSpan">_processSpaceNode</span>(n, level);
    }

    if (n.is(&#x27;block&#x27;) || n.is(&#x27;atrulers&#x27;)) level++;

    that._processNode(n, level);
  });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.block_indent.detect" id="apidoc.element.csscomb.block_indent.detect">
        function <span class="apidocSignatureSpan">csscomb.block_indent.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect(ast) {
  var detected = [];

  ast.traverse(function (node) {
    // Continue only with non-empty {...} blocks:
    if (!node.is(&#x27;atrulers&#x27;) &#x26;&#x26; !node.is(&#x27;block&#x27;) || !node.length) return;

    node.eachFor(&#x27;space&#x27;, function (whitespaceNode) {
      var spaces = whitespaceNode.content;
      var lastIndex = spaces.lastIndexOf(&#x27;\n&#x27;);

      // Do not continue if there is no line break:
      if (lastIndex &#x3c; 0) return;

      // Number of spaces from beginning of line:
      var spacesLength = spaces.slice(lastIndex + 1).length + 1;
      detected.push(new Array(spacesLength).join(&#x27; &#x27;));
    });
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.block_indent.process" id="apidoc.element.csscomb.block_indent.process">
        function <span class="apidocSignatureSpan">csscomb.block_indent.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  ast.eachFor(&#x27;space&#x27;, function (whitespaceNode, i) {
    var spaces = whitespaceNode.content.replace(/\n[ \t]+/gm, &#x27;\n&#x27;);

    if (spaces === &#x27;&#x27;) {
      ast.remove(i);
    } else {
      whitespaceNode.content = spaces;
    }
  });

  this._processNode(ast, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.color_case" id="apidoc.module.csscomb.color_case">module csscomb.color_case</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.color_case.detect" id="apidoc.element.csscomb.color_case.detect">
        function <span class="apidocSignatureSpan">csscomb.color_case.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect(ast) {
  var detected = [];

  ast.traverseByType(&#x27;color&#x27;, function (color) {
    if (color.content.match(/^[^A-F]*[a-f][^A-F]*$/)) {
      detected.push(&#x27;lower&#x27;);
    } else if (color.content.match(/^[^a-f]*[A-F][^a-f]*$/)) {
      detected.push(&#x27;upper&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.color_case.process" id="apidoc.element.csscomb.color_case.process">
        function <span class="apidocSignatureSpan">csscomb.color_case.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  var value = this.value;

  ast.traverseByType(&#x27;color&#x27;, function (color) {
    color.content = value === &#x27;lower&#x27; ? color.content.toLowerCase() : color.content.toUpperCase();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.color_shorthand" id="apidoc.module.csscomb.color_shorthand">module csscomb.color_shorthand</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.color_shorthand.detect" id="apidoc.element.csscomb.color_shorthand.detect">
        function <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect(ast) {
  var detected = [];

  ast.traverseByType(&#x27;color&#x27;, function (color) {
    if (color.content.match(/^\w{3}$/)) {
      detected.push(true);
    } else if (color.content.match(/^(\w)\1(\w)\2(\w)\3$/)) {
      detected.push(false);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.color_shorthand.process" id="apidoc.element.csscomb.color_shorthand.process">
        function <span class="apidocSignatureSpan">csscomb.color_shorthand.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  var value = this.value;

  ast.traverseByType(&#x27;color&#x27;, function (color) {
    color.content = value ? color.content.replace(/(\w)\1(\w)\2(\w)\3/i, &#x27;$1$2$3&#x27;) : color.content.replace(/^(\w)(\w)(\w)$/, &#x27;$1
$1$2$2$3$3&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.element_case" id="apidoc.module.csscomb.element_case">module csscomb.element_case</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.element_case.detect" id="apidoc.element.csscomb.element_case.detect">
        function <span class="apidocSignatureSpan">csscomb.element_case.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect(ast) {
  let detected = [];

  ast.traverse(node =&#x3e; {
    if (!node.is(&#x27;selector&#x27;) &#x26;&#x26; !node.is(&#x27;arguments&#x27;)) return;

    node.forEach(&#x27;typeSelector&#x27;, selector =&#x3e; {
      selector.forEach(&#x27;ident&#x27;, ident =&#x3e; {
        if (ident.content.match(/^[a-z]+$/)) {
          detected.push(&#x27;lower&#x27;);
        } else if (ident.content.match(/^[A-Z]+$/)) {
          detected.push(&#x27;upper&#x27;);
        }
      });
    });
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.element_case.process" id="apidoc.element.csscomb.element_case.process">
        function <span class="apidocSignatureSpan">csscomb.element_case.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  let value = this.value;

  ast.traverse(node =&#x3e; {
    if (!node.is(&#x27;selector&#x27;) &#x26;&#x26; !node.is(&#x27;arguments&#x27;)) return;

    node.forEach(&#x27;typeSelector&#x27;, selector =&#x3e; {
      selector.forEach(&#x27;ident&#x27;, ident =&#x3e; {
        ident.content = value === &#x27;lower&#x27; ? ident.content.toLowerCase() : ident.content.toUpperCase();
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.eof_newline" id="apidoc.module.csscomb.eof_newline">module csscomb.eof_newline</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.eof_newline.detect" id="apidoc.element.csscomb.eof_newline.detect">
        function <span class="apidocSignatureSpan">csscomb.eof_newline.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect(ast) {
  var lastChild = ast.last();

  if (lastChild.is(&#x27;space&#x27;) &#x26;&#x26; lastChild.content.indexOf(&#x27;\n&#x27;) !== -1) {
    return [true];
  } else {
    return [false];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.eof_newline.process" id="apidoc.element.csscomb.eof_newline.process">
        function <span class="apidocSignatureSpan">csscomb.eof_newline.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  var lastChild = ast.last();

  if (!lastChild.is(&#x27;space&#x27;)) {
    lastChild = gonzales.createNode({ type: &#x27;space&#x27;, content: &#x27;&#x27; });
    ast.content.push(lastChild);
  }

  lastChild.content = lastChild.content.replace(/\n$/, &#x27;&#x27;);
  if (this.value) lastChild.content += &#x27;\n&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.errors" id="apidoc.module.csscomb.errors">module csscomb.errors</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.errors.configParsingError" id="apidoc.element.csscomb.errors.configParsingError">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>configParsingError
        <span class="apidocSignatureSpan">(configPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configParsingError(configPath) {
  return `Error parsing configuration file ${configPath}.`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (configPath.match(/\.css$/)) {
  config = Comb.detectInFile(configPath);
} else {
  config = Comb.getCustomConfig(configPath);
}

if (!config) {
  const errorMessage = Errors.<span class="apidocCodeKeywordSpan">configParsingError</span>(configPath);
  process.stderr.write(errorMessage);
  process.exit(1);
}

applyTemplate(config);
if (options.verbose) config.verbose = options.verbose;
if (options.lint) config.lint = options.lint;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.implementSetValue" id="apidoc.element.csscomb.errors.implementSetValue">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>implementSetValue
        <span class="apidocSignatureSpan">(valueType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">implementSetValue(valueType) {
  if (typeof valueType === &#x27;undefined&#x27;) throw new Error();

  return format(`If you see this message and you are not
      a developer adding a new option, please open an issue here:
      https://github.com/csscomb/core/issues/new\n
      For option to accept values of type &#x22;${valueType}&#x22;
      you need to implement custom \`setValue()\` method.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (valueType = &#x27;string&#x27;) {
  if (!value.match(pattern)) throw new Error(Errors.unacceptableString(pattern));
  this.value_ = value;
  return this.value_;
}

throw new Error(Errors.<span class="apidocCodeKeywordSpan">implementSetValue</span>(valueType));
  },

  validate() {
if (typeof this.name !== &#x27;string&#x27; || !this.name) throw new Error(Errors.missingName());

if (!Array.isArray(this.syntax) || this.syntax.length === 0) throw new Error(Errors.missingSyntax());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.missingName" id="apidoc.element.csscomb.errors.missingName">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>missingName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">missingName() {
  return &#x27;Plugin must have a valid \`name\` property.&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return this.value_;
    }

    throw new Error(Errors.implementSetValue(valueType));
  },

  validate() {
    if (typeof this.name !== &#x27;string&#x27; || !this.name) throw new Error(Errors.<span class="apidocCodeKeywordSpan">missingName
</span>());

    if (!Array.isArray(this.syntax) || this.syntax.length === 0) throw new Error(Errors.missingSyntax());

    if (typeof this.accepts !== &#x27;object&#x27; &#x26;&#x26; typeof this.setValue !== &#x27;function&#x27;) throw new Error(Errors
.missingSetValue());
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.missingSetValue" id="apidoc.element.csscomb.errors.missingSetValue">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>missingSetValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">missingSetValue() {
  return format(`Plugin must either implemet \`setValue()\` method
      or provide \`accepts\` object with acceptable values.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  validate() {
    if (typeof this.name !== &#x27;string&#x27; || !this.name) throw new Error(Errors.missingName());

    if (!Array.isArray(this.syntax) || this.syntax.length === 0) throw new Error(Errors.missingSyntax());

    if (typeof this.accepts !== &#x27;object&#x27; &#x26;&#x26; typeof this.setValue !== &#x27;function&#x27;) throw new Error(Errors
.<span class="apidocCodeKeywordSpan">missingSetValue</span>());
  }
};

module.exports = Plugin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.missingSyntax" id="apidoc.element.csscomb.errors.missingSyntax">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>missingSyntax
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">missingSyntax() {
  return &#x27;Plugin must list supported syntaxes.&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    throw new Error(Errors.implementSetValue(valueType));
  },

  validate() {
    if (typeof this.name !== &#x27;string&#x27; || !this.name) throw new Error(Errors.missingName());

    if (!Array.isArray(this.syntax) || this.syntax.length === 0) throw new Error(Errors.<span class="apidocCodeKeywordSpan">missingSyntax
</span>());

    if (typeof this.accepts !== &#x27;object&#x27; &#x26;&#x26; typeof this.setValue !== &#x27;function&#x27;) throw new Error(Errors
.missingSetValue());
  }
};

module.exports = Plugin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.missingTemplateFile" id="apidoc.element.csscomb.errors.missingTemplateFile">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>missingTemplateFile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">missingTemplateFile(file) {
  return format(`Template configuration file ${file}
                 was not found.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return config;
}

function applyTemplate(config) {
if (!config.template) return;

if (!fs.existsSync(config.template)) {
  const errorMessage = Errors.<span class="apidocCodeKeywordSpan">missingTemplateFile</span>(config.template);
  process.stderr.write(errorMessage);
  process.exit(1);
}

var templateConfig = Comb.detectInFile(config.template);
for (var attrname in templateConfig) {
  if (templateConfig.hasOwnProperty(attrname) &#x26;&#x26; !config[attrname]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.twoPluginsWithSameName" id="apidoc.element.csscomb.errors.twoPluginsWithSameName">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>twoPluginsWithSameName
        <span class="apidocSignatureSpan">(pluginName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">twoPluginsWithSameName(pluginName) {
  if (typeof pluginName === &#x27;undefined&#x27;) throw new Error();

  return format(`You&#x27;re trying to use one plugin twice:
      ${pluginName}. Please make sure there are not two different
      plugins with the same name.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Object} options
   * @return {Comb}
   */
  use(options) {
// Check whether plugin with the same is already used.
let pluginName = options.name;
if (this._pluginAlreadyUsed(pluginName)) {
  if (this.verbose) console.warn(Errors.<span class="apidocCodeKeywordSpan">twoPluginsWithSameName</span>(pluginName));
  return;
}

let plugin = new Plugin(options);

plugin.syntax.forEach(function (s) {
  this.supportedSyntaxes.add(s);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.unacceptableBoolean" id="apidoc.element.csscomb.errors.unacceptableBoolean">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableBoolean
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unacceptableBoolean(pattern) {
  if (typeof pattern === &#x27;undefined&#x27;) throw new Error();

  return `Value must be one of the following: ${pattern.join(&#x27;, &#x27;)}.`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.value_ = this.setValue(value);
  return this.value_;
}

if (!pattern) throw new Error(Errors.unacceptableValueType(valueType, this.accepts));

if (valueType === &#x27;boolean&#x27;) {
  if (pattern.indexOf(value) &#x3c; 0) throw new Error(Errors.<span class="apidocCodeKeywordSpan">unacceptableBoolean</span>(pattern
));
  this.value_ = value;
  return this.value_;
}

if (valueType === &#x27;number&#x27;) {
  if (value !== parseInt(value)) throw new Error(Errors.unacceptableNumber());
  this.value_ = new Array(value + 1).join(&#x27; &#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.unacceptableNumber" id="apidoc.element.csscomb.errors.unacceptableNumber">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unacceptableNumber() {
  return &#x27;Value must be an integer.&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (valueType === &#x27;boolean&#x27;) {
  if (pattern.indexOf(value) &#x3c; 0) throw new Error(Errors.unacceptableBoolean(pattern));
  this.value_ = value;
  return this.value_;
}

if (valueType === &#x27;number&#x27;) {
  if (value !== parseInt(value)) throw new Error(Errors.<span class="apidocCodeKeywordSpan">unacceptableNumber</span>());
  this.value_ = new Array(value + 1).join(&#x27; &#x27;);
  return this.value_;
}

if (valueType = &#x27;string&#x27;) {
  if (!value.match(pattern)) throw new Error(Errors.unacceptableString(pattern));
  this.value_ = value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.unacceptableString" id="apidoc.element.csscomb.errors.unacceptableString">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableString
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unacceptableString(pattern) {
  if (typeof pattern === &#x27;undefined&#x27;) throw new Error();

  return `Value must match pattern ${pattern}.`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (valueType === &#x27;number&#x27;) {
    if (value !== parseInt(value)) throw new Error(Errors.unacceptableNumber());
    this.value_ = new Array(value + 1).join(&#x27; &#x27;);
    return this.value_;
  }

  if (valueType = &#x27;string&#x27;) {
    if (!value.match(pattern)) throw new Error(Errors.<span class="apidocCodeKeywordSpan">unacceptableString</span>(pattern));
    this.value_ = value;
    return this.value_;
  }

  throw new Error(Errors.implementSetValue(valueType));
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.errors.unacceptableValueType" id="apidoc.element.csscomb.errors.unacceptableValueType">
        function <span class="apidocSignatureSpan">csscomb.errors.</span>unacceptableValueType
        <span class="apidocSignatureSpan">(valueType, accepts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unacceptableValueType(valueType, accepts) {
  if (typeof valueType === &#x27;undefined&#x27; || typeof accepts === &#x27;undefined&#x27;) throw new Error();

  return format(`The option does not accept values of type
      ${valueType}.\nValue\&#x27;s type must be one the following:
      ${Object.keys(accepts).join(&#x27;, &#x27;)}.`);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let pattern = this.accepts &#x26;&#x26; this.accepts[valueType];

if (this.setValue) {
  this.value_ = this.setValue(value);
  return this.value_;
}

if (!pattern) throw new Error(Errors.<span class="apidocCodeKeywordSpan">unacceptableValueType</span>(valueType, this.accepts));

if (valueType === &#x27;boolean&#x27;) {
  if (pattern.indexOf(value) &#x3c; 0) throw new Error(Errors.unacceptableBoolean(pattern));
  this.value_ = value;
  return this.value_;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.leading_zero" id="apidoc.module.csscomb.leading_zero">module csscomb.leading_zero</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.leading_zero.detect" id="apidoc.element.csscomb.leading_zero.detect">
        function <span class="apidocSignatureSpan">csscomb.leading_zero.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;number&#x27;, function (number) {
    if (number.content.match(/^\.[0-9]+/)) {
      detected.push(false);
    } else if (number.content.match(/^0\.[0-9]+/)) {
      detected.push(true);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.leading_zero.process" id="apidoc.element.csscomb.leading_zero.process">
        function <span class="apidocSignatureSpan">csscomb.leading_zero.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;number&#x27;, function (number) {
    if (!value) {
      number.content = number.content.replace(/^0+(?=\.)/, &#x27;&#x27;);
    } else if (number.content[0] === &#x27;.&#x27;) {
      number.content = &#x27;0&#x27; + number.content;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.lines_between_rulesets" id="apidoc.module.csscomb.lines_between_rulesets">module csscomb.lines_between_rulesets</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.buildSpacing" id="apidoc.element.csscomb.lines_between_rulesets.buildSpacing">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>buildSpacing
        <span class="apidocSignatureSpan">(syntax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildSpacing(syntax) {
  let spacing = &#x27;&#x27;;
  let numNewLines = 0;
  let newLinesOffset = 1;

  if (syntax === &#x27;sass&#x27;) {
    newLinesOffset = 0;
  }

  numNewLines = Math.round(this.value) + newLinesOffset;

  for (var i = 0; i &#x3c; numNewLines; i++) {
    spacing += &#x27;\n&#x27;;
  }

  return spacing;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Processes ast and fixes found code style errors.
 * @param {Node} ast
 */
process(ast) {
  this.newLinesString = this.<span class="apidocCodeKeywordSpan">buildSpacing</span>(ast.syntax);
  this.newLinesNode = gonzales.createNode({
    type: &#x27;space&#x27;,
    content: this.newLinesString
  });
  this.processBlock(ast);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.findLatestNonCommentNode" id="apidoc.element.csscomb.lines_between_rulesets.findLatestNonCommentNode">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>findLatestNonCommentNode
        <span class="apidocSignatureSpan">(parent, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLatestNonCommentNode(parent, index) {
  let prevChild;
  let lastNonCommentIndex = -1;
  let currentIndex = index;
  let jumpSize = 2;

  if (parent.syntax === &#x27;sass&#x27;) {
    jumpSize = 3;
  }

  while (currentIndex &#x3e;= 0) {
    if (this.prevLineIsComment(parent, currentIndex)) {
      currentIndex -= jumpSize;
      continue;
    }

    prevChild = parent.get(currentIndex - 1);

    if (!this.isComment(prevChild)) {
      lastNonCommentIndex = currentIndex - 1;
      break;
    }

    currentIndex--;
  }

  return lastNonCommentIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  shouldInsert = true;
  break;
}
    }

    if (prevChild &#x26;&#x26; shouldInsert) {
if (this.prevLineIsComment(node, index) || this.isComment(prevChild)) {
  let lastNonCommentIndex = this.<span class="apidocCodeKeywordSpan">findLatestNonCommentNode</span>(node, index);
  prevChild = node.get(lastNonCommentIndex);
}

if (prevChild.is(&#x27;space&#x27;)) {
  this.insertNewlinesAsString(prevChild);
} else {
  this.insertNewlinesAsNode(prevChild);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.insertNewlines" id="apidoc.element.csscomb.lines_between_rulesets.insertNewlines">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>insertNewlines
        <span class="apidocSignatureSpan">(node, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertNewlines(node, index) {
  let prevChild = node.get(index - 1);
  let shouldInsert = false;

  // Check for previous nodes that are not a space
  // Do not insert if the ruleset is the first item
  for (var i = 0; i &#x3c; index; i++) {
    if (!node.get(i).is(&#x27;space&#x27;)) {
      shouldInsert = true;
      break;
    }
  }

  if (prevChild &#x26;&#x26; shouldInsert) {
    if (this.prevLineIsComment(node, index) || this.isComment(prevChild)) {
      let lastNonCommentIndex = this.findLatestNonCommentNode(node, index);
      prevChild = node.get(lastNonCommentIndex);
    }

    if (prevChild.is(&#x27;space&#x27;)) {
      this.insertNewlinesAsString(prevChild);
    } else {
      this.insertNewlinesAsNode(prevChild);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this.processBlock(node);
  });
},

processAtRules(node) {
  node.forEach(&#x27;atrule&#x27;, (atRuleNode, index) =&#x3e; {
    this.<span class="apidocCodeKeywordSpan">insertNewlines</span>(node, index);
  });
},

processRuleSets(node) {
  node.forEach(&#x27;ruleset&#x27;, (ruleSetNode, index) =&#x3e; {
    this.insertNewlines(node, index);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.insertNewlinesAsNode" id="apidoc.element.csscomb.lines_between_rulesets.insertNewlinesAsNode">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>insertNewlinesAsNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertNewlinesAsNode(node) {
  node.insert(node.length, this.newLinesNode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        let lastNonCommentIndex = this.findLatestNonCommentNode(node, index);
        prevChild = node.get(lastNonCommentIndex);
      }

      if (prevChild.is(&#x27;space&#x27;)) {
        this.insertNewlinesAsString(prevChild);
      } else {
        this.<span class="apidocCodeKeywordSpan">insertNewlinesAsNode</span>(prevChild);
      }
    }
  }
};

module.exports = option;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.insertNewlinesAsString" id="apidoc.element.csscomb.lines_between_rulesets.insertNewlinesAsString">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>insertNewlinesAsString
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertNewlinesAsString(node) {
  let content = node.content;
  let lastNewline = content.lastIndexOf(&#x27;\n&#x27;);
  let newContent;

  if (lastNewline &#x3e; -1) {
    content = content.substring(lastNewline + 1);
  }

  newContent = this.newLinesString + content;
  node.content = newContent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (prevChild &#x26;&#x26; shouldInsert) {
      if (this.prevLineIsComment(node, index) || this.isComment(prevChild)) {
        let lastNonCommentIndex = this.findLatestNonCommentNode(node, index);
        prevChild = node.get(lastNonCommentIndex);
      }

      if (prevChild.is(&#x27;space&#x27;)) {
        this.<span class="apidocCodeKeywordSpan">insertNewlinesAsString</span>(prevChild);
      } else {
        this.insertNewlinesAsNode(prevChild);
      }
    }
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.isComment" id="apidoc.element.csscomb.lines_between_rulesets.isComment">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>isComment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComment(node) {
  if (!node) {
    return false;
  }
  return node.is(&#x27;singlelineComment&#x27;) || node.is(&#x27;multilineComment&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  prevChild = parent.get(index - 1);
  prevMinusOneChild = parent.get(index - 2);

  if (parentSyntax === &#x27;sass&#x27;) {
    prevMinusTwoChild = parent.get(index - 3);
    return this.<span class="apidocCodeKeywordSpan">isComment</span>(prevMinusTwoChild) &#x26;&#x26; this.isNewline(prevMinusOneChild
) &#x26;&#x26; prevChild.is(&#x27;space&#x27;);
  }

  return this.isComment(prevMinusOneChild) &#x26;&#x26; prevChild.is(&#x27;space&#x27;);
},

/*
** Find the latest previous child that isn&#x27;t a comment, and return its index.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.isNewline" id="apidoc.element.csscomb.lines_between_rulesets.isNewline">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>isNewline
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNewline(node) {
  if (!node) {
    return false;
  }
  return node.content === &#x27;\n&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  prevChild = parent.get(index - 1);
  prevMinusOneChild = parent.get(index - 2);

  if (parentSyntax === &#x27;sass&#x27;) {
    prevMinusTwoChild = parent.get(index - 3);
    return this.isComment(prevMinusTwoChild) &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">isNewline</span>(prevMinusOneChild
) &#x26;&#x26; prevChild.is(&#x27;space&#x27;);
  }

  return this.isComment(prevMinusOneChild) &#x26;&#x26; prevChild.is(&#x27;space&#x27;);
},

/*
** Find the latest previous child that isn&#x27;t a comment, and return its index.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.prevLineIsComment" id="apidoc.element.csscomb.lines_between_rulesets.prevLineIsComment">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>prevLineIsComment
        <span class="apidocSignatureSpan">(parent, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prevLineIsComment(parent, index) {
  let indexThreshold = 2;
  let prevChild;
  let prevMinusOneChild;
  let prevMinusTwoChild;
  let parentSyntax = parent ? parent.syntax : null;

  // Sass is troublesome because newlines are counted as separate nodes
  if (parentSyntax === &#x27;sass&#x27;) {
    indexThreshold = 3;
  }

  if (!parent || index &#x3c; indexThreshold) {
    return false;
  }

  prevChild = parent.get(index - 1);
  prevMinusOneChild = parent.get(index - 2);

  if (parentSyntax === &#x27;sass&#x27;) {
    prevMinusTwoChild = parent.get(index - 3);
    return this.isComment(prevMinusTwoChild) &#x26;&#x26; this.isNewline(prevMinusOneChild) &#x26;&#x26; prevChild.is(&#x27;space&#x27;);
  }

  return this.isComment(prevMinusOneChild) &#x26;&#x26; prevChild.is(&#x27;space&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    let jumpSize = 2;

    if (parent.syntax === &#x27;sass&#x27;) {
jumpSize = 3;
    }

    while (currentIndex &#x3e;= 0) {
if (this.<span class="apidocCodeKeywordSpan">prevLineIsComment</span>(parent, currentIndex)) {
  currentIndex -= jumpSize;
  continue;
}

prevChild = parent.get(currentIndex - 1);

if (!this.isComment(prevChild)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.process" id="apidoc.element.csscomb.lines_between_rulesets.process">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast) {
  this.newLinesString = this.buildSpacing(ast.syntax);
  this.newLinesNode = gonzales.createNode({
    type: &#x27;space&#x27;,
    content: this.newLinesString
  });
  this.processBlock(ast);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.processAtRules" id="apidoc.element.csscomb.lines_between_rulesets.processAtRules">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>processAtRules
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processAtRules(node) {
  node.forEach(&#x27;atrule&#x27;, (atRuleNode, index) =&#x3e; {
    this.insertNewlines(node, index);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
this.processBlock(ast);
  },

  processBlock(x) {
if (x.is(&#x27;stylesheet&#x27;)) {
  // Check all @rules
  this.<span class="apidocCodeKeywordSpan">processAtRules</span>(x);

  // Check all rulesets
  this.processRuleSets(x);
}

x.forEach(node =&#x3e; {
  if (!node.is(&#x27;block&#x27;)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.processBlock" id="apidoc.element.csscomb.lines_between_rulesets.processBlock">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>processBlock
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processBlock(x) {
  if (x.is(&#x27;stylesheet&#x27;)) {
    // Check all @rules
    this.processAtRules(x);

    // Check all rulesets
    this.processRuleSets(x);
  }

  x.forEach(node =&#x3e; {
    if (!node.is(&#x27;block&#x27;)) {
      return this.processBlock(node);
    }

    // Check all @rules
    this.processAtRules(node);

    // Check all rulesets
    this.processRuleSets(node);

    this.processBlock(node);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
process(ast) {
  this.newLinesString = this.buildSpacing(ast.syntax);
  this.newLinesNode = gonzales.createNode({
    type: &#x27;space&#x27;,
    content: this.newLinesString
  });
  this.<span class="apidocCodeKeywordSpan">processBlock</span>(ast);
},

processBlock(x) {
  if (x.is(&#x27;stylesheet&#x27;)) {
    // Check all @rules
    this.processAtRules(x);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.processRuleSets" id="apidoc.element.csscomb.lines_between_rulesets.processRuleSets">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>processRuleSets
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processRuleSets(node) {
  node.forEach(&#x27;ruleset&#x27;, (ruleSetNode, index) =&#x3e; {
    this.insertNewlines(node, index);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  processBlock(x) {
if (x.is(&#x27;stylesheet&#x27;)) {
  // Check all @rules
  this.processAtRules(x);

  // Check all rulesets
  this.<span class="apidocCodeKeywordSpan">processRuleSets</span>(x);
}

x.forEach(node =&#x3e; {
  if (!node.is(&#x27;block&#x27;)) {
    return this.processBlock(node);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.lines_between_rulesets.setValue" id="apidoc.element.csscomb.lines_between_rulesets.setValue">
        function <span class="apidocSignatureSpan">csscomb.lines_between_rulesets.</span>setValue
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValue(value) {
  let valueType = typeof value;

  if (valueType !== &#x27;number&#x27;) {
    throw new Error(&#x27;Value must be a number.&#x27;);
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.value_;
  },
  set value(value) {
let valueType = typeof value;
let pattern = this.accepts &#x26;&#x26; this.accepts[valueType];

if (this.setValue) {
  this.value_ = this.<span class="apidocCodeKeywordSpan">setValue</span>(value);
  return this.value_;
}

if (!pattern) throw new Error(Errors.unacceptableValueType(valueType, this.accepts));

if (valueType === &#x27;boolean&#x27;) {
  if (pattern.indexOf(value) &#x3c; 0) throw new Error(Errors.unacceptableBoolean(pattern));
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.plugin" id="apidoc.module.csscomb.plugin">module csscomb.plugin</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.plugin.plugin" id="apidoc.element.csscomb.plugin.plugin">
        function <span class="apidocSignatureSpan">csscomb.</span>plugin
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plugin = function (methods) {
  for (let method in methods) {
    this[method] = typeof method === &#x27;function&#x27; ? methods[method].bind(this) : methods[method];
  }

  this.validate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.plugin.prototype" id="apidoc.module.csscomb.plugin.prototype">module csscomb.plugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.plugin.prototype.validate" id="apidoc.element.csscomb.plugin.prototype.validate">
        function <span class="apidocSignatureSpan">csscomb.plugin.prototype.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate() {
  if (typeof this.name !== &#x27;string&#x27; || !this.name) throw new Error(Errors.missingName());

  if (!Array.isArray(this.syntax) || this.syntax.length === 0) throw new Error(Errors.missingSyntax());

  if (typeof this.accepts !== &#x27;object&#x27; &#x26;&#x26; typeof this.setValue !== &#x27;function&#x27;) throw new Error(Errors.missingSetValue());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
let Errors = require(&#x27;./errors&#x27;);

let Plugin = function (methods) {
for (let method in methods) {
  this[method] = typeof method === &#x27;function&#x27; ? methods[method].bind(this) : methods[method];
}

this.<span class="apidocCodeKeywordSpan">validate</span>();
};

Plugin.prototype = {
/**
 * Plugin&#x27;s name.
 * @type {String}
 */
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.quotes" id="apidoc.module.csscomb.quotes">module csscomb.quotes</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.quotes.detect" id="apidoc.element.csscomb.quotes.detect">
        function <span class="apidocSignatureSpan">csscomb.quotes.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;string&#x27;, function (string) {
    if (string.content[0] === &#x27;&#x22;&#x27;) {
      detected.push(&#x27;double&#x27;);
    } else if (string.content[0] === &#x27;\&#x27;&#x27;) {
      detected.push(&#x27;single&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.quotes.process" id="apidoc.element.csscomb.quotes.process">
        function <span class="apidocSignatureSpan">csscomb.quotes.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;string&#x27;, function (string) {
    if (string.content[0] === &#x27;&#x22;&#x27; &#x26;&#x26; value === &#x27;single&#x27;) {
      string.content = string.content
      // Unescape all escaped double quotes
      .replace(/\\&#x22;/g, &#x27;&#x22;&#x27;)
      // Escape all the single quotes
      .replace(/([^\\])&#x27;/g, &#x27;$1\\\&#x27;&#x27;)
      // Replace the first and the last quote
      .replace(/^&#x22;|&#x22;$/g, &#x27;\&#x27;&#x27;);
    } else if (string.content[0] === &#x27;\&#x27;&#x27; &#x26;&#x26; value === &#x27;double&#x27;) {
      string.content = string.content
      // Unescape all escaped single quotes
      .replace(/\\&#x27;/g, &#x27;\&#x27;&#x27;)
      // Escape all the double quotes
      .replace(/([^\\])&#x22;/g, &#x27;$1\\\&#x22;&#x27;)
      // Replace the first and the last quote
      .replace(/^&#x27;|&#x27;$/g, &#x27;&#x22;&#x27;);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.remove_empty_rulesets" id="apidoc.module.csscomb.remove_empty_rulesets">module csscomb.remove_empty_rulesets</a></h1>




    <h2>
        <a href="#apidoc.element.csscomb.remove_empty_rulesets.detect" id="apidoc.element.csscomb.remove_empty_rulesets.detect">
        function <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverse(function (node) {
    if (!node.is(&#x27;atrulers&#x27;) &#x26;&#x26; !node.is(&#x27;block&#x27;)) return;

    if (node.length === 0 || node.length === 1 &#x26;&#x26; node.first().is(&#x27;space&#x27;)) {
      detected.push(false);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.remove_empty_rulesets.process" id="apidoc.element.csscomb.remove_empty_rulesets.process">
        function <span class="apidocSignatureSpan">csscomb.remove_empty_rulesets.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  processNode(ast);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.sort_order" id="apidoc.module.csscomb.sort_order">module csscomb.sort_order</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.sort_order._cleanSassLinebreaks" id="apidoc.element.csscomb.sort_order._cleanSassLinebreaks">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_cleanSassLinebreaks
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanSassLinebreaks(node) {
  let containsOnlyLinebreaks = true;

  node.forEach(space =&#x3e; {
    if (!space.is(&#x27;space&#x27;) || space.content !== &#x27;\n&#x27;) {
      containsOnlyLinebreaks = false;
      return null;
    }
  });

  if (containsOnlyLinebreaks) node.content = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  positions.push(i);
}

return sendPositions ? positions : null;
  },

  _insertSortablesToBlock(nodesToSort, node) {
if (node.syntax === &#x27;sass&#x27;) this.<span class="apidocCodeKeywordSpan">_cleanSassLinebreaks</span>(node);

for (let i = nodesToSort.length - 1, l = -1; i &#x3e; l; i--) {
  let currentNode = nodesToSort[i];
  let prevNode = nodesToSort[i - 1];
  let spacesBeforeNode = currentNode.spacesBeforeNode || [];
  let spacesBeforeDelimiter = currentNode.spacesBeforeDelimiter || [];
  let spacesAfterDelimiter = currentNode.spacesAfterDelimiter || [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._extendNode" id="apidoc.element.csscomb.sort_order._extendNode">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_extendNode
        <span class="apidocSignatureSpan">(block, i, spacesBefore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_extendNode(block, i, spacesBefore) {
  let nodesToDelete = [i];
  let node = block.get(i);
  let extendedNode = { i: i, node: node };

  let propertyName = this._getSortableName(node);
  if (!propertyName) return null;

  // Check if current node&#x27;s property name is in sort order.
  let propertyIndex = this.value[propertyName];
  // If the declaration&#x27;s property is in order&#x27;s list, save its
  // group and property indices. Otherwise set them to 10000, so
  // declaration appears at the bottom of a sorted list:
  extendedNode.groupIndex = propertyIndex &#x26;&#x26; propertyIndex.group &#x3e; -1 ? propertyIndex.group : this._getLastGroupIndex();
  extendedNode.propertyIndex = propertyIndex &#x26;&#x26; propertyIndex.prop &#x3e; -1 ? propertyIndex.prop : this._getLastPropertyIndex();

  // Spaces before node.
  nodesToDelete = nodesToDelete.concat(spacesBefore);
  extendedNode.spacesBeforeNode = this._getNodesByIndex(block, spacesBefore);

  // Spaces after node.
  let spacesBeforeDelimiter = this._getSpacesAndCommentsAfterNode(block, i);
  nodesToDelete = nodesToDelete.concat(spacesBeforeDelimiter);
  extendedNode.spacesBeforeDelimiter = this._getNodesByIndex(block, spacesBeforeDelimiter);

  i += spacesBeforeDelimiter.length;

  // Spaces after delimiter.
  // If there is `;` right after the declaration, save it with the
  // declaration and mark it for removing from parent node:
  if (block.get(i + 1) &#x26;&#x26; block.get(i + 1).is(&#x27;declarationDelimiter&#x27;)) {
    i += 1;
    node = block.get(i);
    nodesToDelete.push(i);
    extendedNode.delim = node;

    if (node.syntax !== &#x27;sass&#x27;) {
      // Save spaces and comments which follow right after
      // the declaration and mark them for removing from parent node:
      let spacesAfterDelimiter = this._getSpacesAndCommentsAfterNode(block, i);
      i += spacesAfterDelimiter.length;
      nodesToDelete = nodesToDelete.concat(spacesAfterDelimiter);
      extendedNode.spacesAfterDelimiter = this._getNodesByIndex(block, spacesAfterDelimiter);
    }
  }

  extendedNode.endIndex = i;
  // Remove all nodes, that were moved to `sortables` list,
  // from block node:
  extendedNode.nodesToDelete = nodesToDelete;

  return extendedNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // and mark them for removing from parent node:
  let spacesBeforeNode = this._getSpacesAndCommentsBeforeNode(block, i);
  if (!spacesBeforeNode) break;

  i += spacesBeforeNode.length;
  node = block.get(i);

  let extendedNode = this.<span class="apidocCodeKeywordSpan">_extendNode</span>(block, i, spacesBeforeNode);
  if (!extendedNode) continue;

  nodesToDelete = nodesToDelete.concat(extendedNode.nodesToDelete);
  i = extendedNode.endIndex;
  sortables.push(extendedNode);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getLastGroupIndex" id="apidoc.element.csscomb.sort_order._getLastGroupIndex">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getLastGroupIndex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getLastGroupIndex() {
  return this.value &#x26;&#x26; this.value[&#x27;...&#x27;] ? this.value[&#x27;...&#x27;].group : Infinity;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!propertyName) return null;

// Check if current node&#x27;s property name is in sort order.
let propertyIndex = this.value[propertyName];
// If the declaration&#x27;s property is in order&#x27;s list, save its
// group and property indices. Otherwise set them to 10000, so
// declaration appears at the bottom of a sorted list:
extendedNode.groupIndex = propertyIndex &#x26;&#x26; propertyIndex.group &#x3e; -1 ? propertyIndex.group : this.<span class="apidocCodeKeywordSpan
">_getLastGroupIndex</span>();
extendedNode.propertyIndex = propertyIndex &#x26;&#x26; propertyIndex.prop &#x3e; -1 ? propertyIndex.prop : this._getLastPropertyIndex
();

// Spaces before node.
nodesToDelete = nodesToDelete.concat(spacesBefore);
extendedNode.spacesBeforeNode = this._getNodesByIndex(block, spacesBefore);

// Spaces after node.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getLastPropertyIndex" id="apidoc.element.csscomb.sort_order._getLastPropertyIndex">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getLastPropertyIndex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getLastPropertyIndex() {
  return this.value &#x26;&#x26; this.value[&#x27;...&#x27;] ? this.value[&#x27;...&#x27;].prop : Infinity;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Check if current node&#x27;s property name is in sort order.
let propertyIndex = this.value[propertyName];
// If the declaration&#x27;s property is in order&#x27;s list, save its
// group and property indices. Otherwise set them to 10000, so
// declaration appears at the bottom of a sorted list:
extendedNode.groupIndex = propertyIndex &#x26;&#x26; propertyIndex.group &#x3e; -1 ? propertyIndex.group : this._getLastGroupIndex
();
extendedNode.propertyIndex = propertyIndex &#x26;&#x26; propertyIndex.prop &#x3e; -1 ? propertyIndex.prop : this.<span class="apidocCodeKeywordSpan
">_getLastPropertyIndex</span>();

// Spaces before node.
nodesToDelete = nodesToDelete.concat(spacesBefore);
extendedNode.spacesBeforeNode = this._getNodesByIndex(block, spacesBefore);

// Spaces after node.
let spacesBeforeDelimiter = this._getSpacesAndCommentsAfterNode(block, i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getNodesByIndex" id="apidoc.element.csscomb.sort_order._getNodesByIndex">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getNodesByIndex
        <span class="apidocSignatureSpan">(block, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getNodesByIndex(block, index) {
  return index.map(i =&#x3e; block.get(i));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// group and property indices. Otherwise set them to 10000, so
// declaration appears at the bottom of a sorted list:
extendedNode.groupIndex = propertyIndex &#x26;&#x26; propertyIndex.group &#x3e; -1 ? propertyIndex.group : this._getLastGroupIndex
();
extendedNode.propertyIndex = propertyIndex &#x26;&#x26; propertyIndex.prop &#x3e; -1 ? propertyIndex.prop : this._getLastPropertyIndex
();

// Spaces before node.
nodesToDelete = nodesToDelete.concat(spacesBefore);
extendedNode.spacesBeforeNode = this.<span class="apidocCodeKeywordSpan">_getNodesByIndex</span>(block, spacesBefore);

// Spaces after node.
let spacesBeforeDelimiter = this._getSpacesAndCommentsAfterNode(block, i);
nodesToDelete = nodesToDelete.concat(spacesBeforeDelimiter);
extendedNode.spacesBeforeDelimiter = this._getNodesByIndex(block, spacesBeforeDelimiter);

i += spacesBeforeDelimiter.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getSortableIncludeName" id="apidoc.element.csscomb.sort_order._getSortableIncludeName">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSortableIncludeName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSortableIncludeName(node) {
  // Divide `include` into mixins with specific name
  // (e. g. `$include breakpoint`), and the rest  `$include`.
  let mixinName;

  if (node.syntax === &#x27;less&#x27;) {
    // `node.first()` is class and `node.first().first()` is ident.
    mixinName = node.first().first().content;
  } else if (node.syntax === &#x27;sass&#x27; &#x26;&#x26; node.first().content === &#x27;+&#x27;) {
    // `node.first()` is `+` and `node.get(1)` is ident.
    mixinName = node.get(1).content;
  } else {
    // `node.first()` is @-keyword, `node.get(1)` is space and
    // `node.get(2)` is ident.
    mixinName = node.get(2).content;
  }

  let includeMixinName = &#x27;$include &#x27; + mixinName;
  return this.value.hasOwnProperty(includeMixinName) ? includeMixinName : &#x27;$include&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  let includeMixinName = &#x27;$include &#x27; + mixinName;
  return this.value.hasOwnProperty(includeMixinName) ? includeMixinName : &#x27;$include&#x27;;
},

_getSortableName(node) {
  if (node.is(&#x27;extend&#x27;)) return &#x27;$extend&#x27;;
  if (node.is(&#x27;include&#x27;)) return this.<span class="apidocCodeKeywordSpan">_getSortableIncludeName</span>(node);else return
 this._getSortablePropertyName(node);
},

_getSortablePropertyName(node) {
  if (node.is(&#x27;declaration&#x27;)) {
    let property = node.first(&#x27;property&#x27;).first();
    return property.is(&#x27;variable&#x27;) ? &#x27;$variable&#x27; : property.content;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getSortableName" id="apidoc.element.csscomb.sort_order._getSortableName">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSortableName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSortableName(node) {
  if (node.is(&#x27;extend&#x27;)) return &#x27;$extend&#x27;;
  if (node.is(&#x27;include&#x27;)) return this._getSortableIncludeName(node);else return this._getSortablePropertyName(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  _extendNode(block, i, spacesBefore) {
let nodesToDelete = [i];
let node = block.get(i);
let extendedNode = { i: i, node: node };

let propertyName = this.<span class="apidocCodeKeywordSpan">_getSortableName</span>(node);
if (!propertyName) return null;

// Check if current node&#x27;s property name is in sort order.
let propertyIndex = this.value[propertyName];
// If the declaration&#x27;s property is in order&#x27;s list, save its
// group and property indices. Otherwise set them to 10000, so
// declaration appears at the bottom of a sorted list:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getSortablePropertyName" id="apidoc.element.csscomb.sort_order._getSortablePropertyName">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSortablePropertyName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSortablePropertyName(node) {
  if (node.is(&#x27;declaration&#x27;)) {
    let property = node.first(&#x27;property&#x27;).first();
    return property.is(&#x27;variable&#x27;) ? &#x27;$variable&#x27; : property.content;
  }

  let atkeyword = node.first(&#x27;atkeyword&#x27;);
  if (atkeyword &#x26;&#x26; atkeyword.first().content === &#x27;import&#x27;) return &#x27;$import&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  let includeMixinName = &#x27;$include &#x27; + mixinName;
  return this.value.hasOwnProperty(includeMixinName) ? includeMixinName : &#x27;$include&#x27;;
},

_getSortableName(node) {
  if (node.is(&#x27;extend&#x27;)) return &#x27;$extend&#x27;;
  if (node.is(&#x27;include&#x27;)) return this._getSortableIncludeName(node);else return this.<span class="apidocCodeKeywordSpan
">_getSortablePropertyName</span>(node);
},

_getSortablePropertyName(node) {
  if (node.is(&#x27;declaration&#x27;)) {
    let property = node.first(&#x27;property&#x27;).first();
    return property.is(&#x27;variable&#x27;) ? &#x27;$variable&#x27; : property.content;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getSpacesAndCommentsAfterNode" id="apidoc.element.csscomb.sort_order._getSpacesAndCommentsAfterNode">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSpacesAndCommentsAfterNode
        <span class="apidocSignatureSpan">(node, i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSpacesAndCommentsAfterNode(node, i) {
  // List of start positions for nodes with spaces and comments:
  let positions = [];

  // Skip node itself.
  i++;

  for (let l = node.length; i &#x3c; l; i++) {
    let currentNode = node.get(i);

    // If node is nor spaces neither comment, stop.
    if (!this._isSpaceOrComment(currentNode)) break;

    if (currentNode.is(&#x27;multilineComment&#x27;) || currentNode.is(&#x27;singlelineComment&#x27;)) {
      positions.push(i);
      continue;
    }

    // If there are any line breaks in a node with spaces, stop and
    // split the node into two: one with spaces before line break
    // and one with `\n` symbol and everything that goes after.
    // Combine the first one with declaration/@-rule&#x27;s node:
    let linebreakIndex = currentNode.content.indexOf(&#x27;\n&#x27;);
    if (linebreakIndex !== -1) {
      var s = currentNode.content.substring(0, linebreakIndex);
      if (s === &#x27;&#x27;) break;
      var space = gonzales.createNode({ type: &#x27;space&#x27;, content: s });
      node.insert(i + 1, space);
      positions.push(i + 1);
      currentNode.content = currentNode.content.substring(linebreakIndex);
      break;
    }

    positions.push(i);
  }

  return positions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extendedNode.propertyIndex = propertyIndex &#x26;&#x26; propertyIndex.prop &#x3e; -1 ? propertyIndex.prop : this._getLastPropertyIndex
();

// Spaces before node.
nodesToDelete = nodesToDelete.concat(spacesBefore);
extendedNode.spacesBeforeNode = this._getNodesByIndex(block, spacesBefore);

// Spaces after node.
let spacesBeforeDelimiter = this.<span class="apidocCodeKeywordSpan">_getSpacesAndCommentsAfterNode</span>(block, i);
nodesToDelete = nodesToDelete.concat(spacesBeforeDelimiter);
extendedNode.spacesBeforeDelimiter = this._getNodesByIndex(block, spacesBeforeDelimiter);

i += spacesBeforeDelimiter.length;

// Spaces after delimiter.
// If there is `;` right after the declaration, save it with the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._getSpacesAndCommentsBeforeNode" id="apidoc.element.csscomb.sort_order._getSpacesAndCommentsBeforeNode">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_getSpacesAndCommentsBeforeNode
        <span class="apidocSignatureSpan">(node, i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSpacesAndCommentsBeforeNode(node, i) {
  // List of start positions for nodes with spaces and comments:
  let positions = [];
  let sendPositions = false;

  for (let l = node.length; i &#x3c; l; i++) {
    let currentNode = node.get(i);

    // If the node is declaration or @-rule, stop and return all
    // found nodes with spaces and comments (if there are any):
    if (!this._isSpaceOrComment(currentNode)) {
      sendPositions = true;
      break;
    }

    positions.push(i);
  }

  return sendPositions ? positions : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Don&#x27;t cache `block.length` since we may insert new nodes into it.
    for (let i = 0; i &#x3c; block.length; i++) {
let node = block.get(i);
if (!this._isAcceptableNode(node)) continue;

// Save preceding spaces and comments, if there are any,
// and mark them for removing from parent node:
let spacesBeforeNode = this.<span class="apidocCodeKeywordSpan">_getSpacesAndCommentsBeforeNode</span>(block, i);
if (!spacesBeforeNode) break;

i += spacesBeforeNode.length;
node = block.get(i);

let extendedNode = this._extendNode(block, i, spacesBeforeNode);
if (!extendedNode) continue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._insertSortablesToBlock" id="apidoc.element.csscomb.sort_order._insertSortablesToBlock">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_insertSortablesToBlock
        <span class="apidocSignatureSpan">(nodesToSort, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insertSortablesToBlock(nodesToSort, node) {
  if (node.syntax === &#x27;sass&#x27;) this._cleanSassLinebreaks(node);

  for (let i = nodesToSort.length - 1, l = -1; i &#x3e; l; i--) {
    let currentNode = nodesToSort[i];
    let prevNode = nodesToSort[i - 1];
    let spacesBeforeNode = currentNode.spacesBeforeNode || [];
    let spacesBeforeDelimiter = currentNode.spacesBeforeDelimiter || [];
    let spacesAfterDelimiter = currentNode.spacesAfterDelimiter || [];

    if (node.syntax === &#x27;sass&#x27; &#x26;&#x26; spacesBeforeNode.length) {
      let space = spacesBeforeNode[0];
      space.content = space.content.replace(/\n/, &#x27;&#x27;);
    }

    spacesBeforeNode.reverse().map(this._removeEmptyLines);
    spacesBeforeDelimiter.reverse().map(this._removeEmptyLines);
    spacesAfterDelimiter.reverse().map(this._removeEmptyLines);

    // Divide declarations from different groups with
    // an empty line:
    if (prevNode &#x26;&#x26; currentNode.groupIndex &#x3e; prevNode.groupIndex) {
      let space = spacesBeforeNode[0];
      if (space &#x26;&#x26; space.is(&#x27;space&#x27;) &#x26;&#x26; (space.syntax === &#x27;sass&#x27; || space.content.match(/\n/g) &#x26;&#x26; space.content.match(/\n/g).length
 &#x3c; 2)) {
        space.content = &#x27;\n&#x27; + space.content;
      }
    }

    for (let j = 0, nl = spacesAfterDelimiter.length; j &#x3c; nl; j++) {
      node.content.unshift(spacesAfterDelimiter[j]);
    }

    if (currentNode.delim) {
      node.content.unshift(currentNode.delim);
    } else if (i !== nodesToSort.length - 1 &#x26;&#x26; (currentNode.node.is(&#x27;declaration&#x27;) || currentNode.node.is(&#x27;extend&#x27;))) {
      let delimiter = gonzales.createNode({
        type: &#x27;declarationDelimiter&#x27;,
        content: currentNode.node.syntax === &#x27;sass&#x27; ? &#x27;\n&#x27; : &#x27;;&#x27;
      });
      node.content.unshift(delimiter);
    }

    for (let j = 0, nl = spacesBeforeDelimiter.length; j &#x3c; nl; j++) {
      node.content.unshift(spacesBeforeDelimiter[j]);
    }

    node.content.unshift(currentNode.node);

    for (let j = 0, nl = spacesBeforeNode.length; j &#x3c; nl; j++) {
      node.content.unshift(spacesBeforeNode[j]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Check every child node.
  // If it is declaration (property-value pair, e.g. `color: tomato`),
  // or @-rule (e.g. `@include nani`),
  // combine it with spaces, semicolon and comments and move them from
  // current node to a separate list for further sorting:
  let nodesToSort = this._separateSortablesFromBlock(block);
  this._sortNodes(nodesToSort);
  this.<span class="apidocCodeKeywordSpan">_insertSortablesToBlock</span>(nodesToSort, block);
},

/**
 * Remove empty lines in space node.
 * @param {node} node Space node.
 */
_removeEmptyLines(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._isAcceptableNode" id="apidoc.element.csscomb.sort_order._isAcceptableNode">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_isAcceptableNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isAcceptableNode(node) {
  const NODES = [&#x27;atrule&#x27;, &#x27;declaration&#x27;, &#x27;extend&#x27;, &#x27;include&#x27;, &#x27;multilineComment&#x27;, &#x27;singlelineComment&#x27;, &#x27;space&#x27;];
  return NODES.indexOf(node.type) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  _separateSortablesFromBlock(block) {
    let sortables = [];
    let nodesToDelete = [];

    // Don&#x27;t cache `block.length` since we may insert new nodes into it.
    for (let i = 0; i &#x3c; block.length; i++) {
let node = block.get(i);
if (!this.<span class="apidocCodeKeywordSpan">_isAcceptableNode</span>(node)) continue;

// Save preceding spaces and comments, if there are any,
// and mark them for removing from parent node:
let spacesBeforeNode = this._getSpacesAndCommentsBeforeNode(block, i);
if (!spacesBeforeNode) break;

i += spacesBeforeNode.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._isSpaceOrComment" id="apidoc.element.csscomb.sort_order._isSpaceOrComment">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_isSpaceOrComment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isSpaceOrComment(node) {
  const SC = [&#x27;multilineComment&#x27;, &#x27;singlelineComment&#x27;, &#x27;space&#x27;];
  return SC.indexOf(node.type) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Skip node itself.
    i++;

    for (let l = node.length; i &#x3c; l; i++) {
let currentNode = node.get(i);

// If node is nor spaces neither comment, stop.
if (!this.<span class="apidocCodeKeywordSpan">_isSpaceOrComment</span>(currentNode)) break;

if (currentNode.is(&#x27;multilineComment&#x27;) || currentNode.is(&#x27;singlelineComment&#x27;)) {
  positions.push(i);
  continue;
}

// If there are any line breaks in a node with spaces, stop and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._processBlock" id="apidoc.element.csscomb.sort_order._processBlock">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_processBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processBlock(block) {
  // Check every child node.
  // If it is declaration (property-value pair, e.g. `color: tomato`),
  // or @-rule (e.g. `@include nani`),
  // combine it with spaces, semicolon and comments and move them from
  // current node to a separate list for further sorting:
  let nodesToSort = this._separateSortablesFromBlock(block);
  this._sortNodes(nodesToSort);
  this._insertSortablesToBlock(nodesToSort, block);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._removeEmptyLines" id="apidoc.element.csscomb.sort_order._removeEmptyLines">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_removeEmptyLines
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_removeEmptyLines(node) {
  node.content = node.content.replace(/\n[\s\t\n\r]*\n/, &#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._separateSortablesFromBlock" id="apidoc.element.csscomb.sort_order._separateSortablesFromBlock">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_separateSortablesFromBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_separateSortablesFromBlock(block) {
  let sortables = [];
  let nodesToDelete = [];

  // Don&#x27;t cache `block.length` since we may insert new nodes into it.
  for (let i = 0; i &#x3c; block.length; i++) {
    let node = block.get(i);
    if (!this._isAcceptableNode(node)) continue;

    // Save preceding spaces and comments, if there are any,
    // and mark them for removing from parent node:
    let spacesBeforeNode = this._getSpacesAndCommentsBeforeNode(block, i);
    if (!spacesBeforeNode) break;

    i += spacesBeforeNode.length;
    node = block.get(i);

    let extendedNode = this._extendNode(block, i, spacesBeforeNode);
    if (!extendedNode) continue;

    nodesToDelete = nodesToDelete.concat(extendedNode.nodesToDelete);
    i = extendedNode.endIndex;
    sortables.push(extendedNode);
  }

  nodesToDelete.sort((a, b) =&#x3e; a - b);
  for (let x = nodesToDelete.length - 1; x &#x3e; -1; x--) block.removeChild(nodesToDelete[x]);

  return sortables;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_processBlock(block) {
  // Check every child node.
  // If it is declaration (property-value pair, e.g. `color: tomato`),
  // or @-rule (e.g. `@include nani`),
  // combine it with spaces, semicolon and comments and move them from
  // current node to a separate list for further sorting:
  let nodesToSort = this.<span class="apidocCodeKeywordSpan">_separateSortablesFromBlock</span>(block);
  this._sortNodes(nodesToSort);
  this._insertSortablesToBlock(nodesToSort, block);
},

/**
 * Remove empty lines in space node.
 * @param {node} node Space node.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._sortLeftovers" id="apidoc.element.csscomb.sort_order._sortLeftovers">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_sortLeftovers
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sortLeftovers(a, b) {
  let prefixes = [&#x27;-webkit-&#x27;, &#x27;-moz-&#x27;, &#x27;-ms-&#x27;, &#x27;-o-&#x27;, &#x27;&#x27;];
  let prefixesRegExp = /^(-webkit-|-moz-|-ms-|-o-)(.*)$/;

  // Get property name (i.e. `color`, `-o-animation`):
  a = a.node.first().first().content;
  b = b.node.first().first().content;

  // Get prefix and unprefixed part. For example:
  // [&#x27;-o-animation&#x27;, &#x27;-o-&#x27;, &#x27;animation&#x27;]
  // [&#x27;color&#x27;, &#x27;&#x27;, &#x27;color&#x27;]
  a = a.match(prefixesRegExp) || [a, &#x27;&#x27;, a];
  b = b.match(prefixesRegExp) || [b, &#x27;&#x27;, b];

  if (a[2] !== b[2]) {
    // If unprefixed parts are different (i.e. `border` and
    // `color`), compare them:
    return a[2] &#x3c;= b[2] ? -1 : 1;
  } else {
    // If unprefixed parts are identical (i.e. `border` in
    // `-moz-border` and `-o-border`), compare prefixes.
    // They should go in the same order they are set
    // in `prefixes` array.
    return prefixes.indexOf(a[1]) &#x3c;= prefixes.indexOf(b[1]) ? -1 : 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If a&#x27;s group index is higher than b&#x27;s group index, in
// a sorted list a appears after b:
if (a.groupIndex !== b.groupIndex) return a.groupIndex - b.groupIndex;

// If a and b belong to leftovers and `sort-order-fallback`
// option is set to `abc`, sort properties alphabetically:
if (a.groupIndex === this._getLastGroupIndex() &#x26;&#x26; this._config[&#x27;sort-order-fallback&#x27;]) {
  return this.<span class="apidocCodeKeywordSpan">_sortLeftovers</span>(a, b);
}

// If a and b have the same group index, and a&#x27;s property index
// is higher than b&#x27;s property index, in a sorted list
// a appears after b:
if (a.propertyIndex !== b.propertyIndex) return a.propertyIndex - b.propertyIndex;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order._sortNodes" id="apidoc.element.csscomb.sort_order._sortNodes">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>_sortNodes
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sortNodes(nodes) {
  nodes.sort((a, b) =&#x3e; {
    // If a&#x27;s group index is higher than b&#x27;s group index, in
    // a sorted list a appears after b:
    if (a.groupIndex !== b.groupIndex) return a.groupIndex - b.groupIndex;

    // If a and b belong to leftovers and `sort-order-fallback`
    // option is set to `abc`, sort properties alphabetically:
    if (a.groupIndex === this._getLastGroupIndex() &#x26;&#x26; this._config[&#x27;sort-order-fallback&#x27;]) {
      return this._sortLeftovers(a, b);
    }

    // If a and b have the same group index, and a&#x27;s property index
    // is higher than b&#x27;s property index, in a sorted list
    // a appears after b:
    if (a.propertyIndex !== b.propertyIndex) return a.propertyIndex - b.propertyIndex;

    // If a and b have the same group index and the same property
    // index, in a sorted list they appear in the same order
    // they were in original array:
    return a.i - b.i;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_processBlock(block) {
  // Check every child node.
  // If it is declaration (property-value pair, e.g. `color: tomato`),
  // or @-rule (e.g. `@include nani`),
  // combine it with spaces, semicolon and comments and move them from
  // current node to a separate list for further sorting:
  let nodesToSort = this._separateSortablesFromBlock(block);
  this.<span class="apidocCodeKeywordSpan">_sortNodes</span>(nodesToSort);
  this._insertSortablesToBlock(nodesToSort, block);
},

/**
 * Remove empty lines in space node.
 * @param {node} node Space node.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order.detect" id="apidoc.element.csscomb.sort_order.detect">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>detect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; []</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order.process" id="apidoc.element.csscomb.sort_order.process">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>process
        <span class="apidocSignatureSpan">(ast, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process(ast, config) {
  this._config = config;
  // Sort properties only inside blocks.
  ast.traverseByType(&#x27;block&#x27;, this._processBlock.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order.setValue" id="apidoc.element.csscomb.sort_order.setValue">
        function <span class="apidocSignatureSpan">csscomb.sort_order.</span>setValue
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValue(value) {
  if (!Array.isArray(value)) throw new Error(&#x27;The option accepts only array of properties.&#x27;);

  var order = {};

  if (typeof value[0] === &#x27;string&#x27;) {
    // If there is only one group of properties.
    value.forEach(function (prop, propIndex) {
      order[prop] = { group: 0, prop: propIndex };
    });
  } else {
    value.forEach(function (group, groupIndex) {
      group.forEach(function (prop, propIndex) {
        order[prop] = { group: groupIndex, prop: propIndex };
      });
    });
  }

  return order;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.value_;
  },
  set value(value) {
let valueType = typeof value;
let pattern = this.accepts &#x26;&#x26; this.accepts[valueType];

if (this.setValue) {
  this.value_ = this.<span class="apidocCodeKeywordSpan">setValue</span>(value);
  return this.value_;
}

if (!pattern) throw new Error(Errors.unacceptableValueType(valueType, this.accepts));

if (valueType === &#x27;boolean&#x27;) {
  if (pattern.indexOf(value) &#x3c; 0) throw new Error(Errors.unacceptableBoolean(pattern));
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.sort_order_fallback" id="apidoc.module.csscomb.sort_order_fallback">module csscomb.sort_order_fallback</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.sort_order_fallback.detect" id="apidoc.element.csscomb.sort_order_fallback.detect">
        function <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>detect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; []</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.sort_order_fallback.process" id="apidoc.element.csscomb.sort_order_fallback.process">
        function <span class="apidocSignatureSpan">csscomb.sort_order_fallback.</span>process
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_after_colon" id="apidoc.module.csscomb.space_after_colon">module csscomb.space_after_colon</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_after_colon.detect" id="apidoc.element.csscomb.space_after_colon.detect">
        function <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;propertyDelimiter&#x27;, function (delimiter, i, parent) {
    if (parent.get(i + 1).is(&#x27;space&#x27;)) {
      detected.push(parent.get(i + 1).content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_after_colon.process" id="apidoc.element.csscomb.space_after_colon.process">
        function <span class="apidocSignatureSpan">csscomb.space_after_colon.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;propertyDelimiter&#x27;, function (delimiter, i, parent) {
    if (delimiter.syntax === &#x27;sass&#x27; &#x26;&#x26; !parent.get(i - 1)) return null;

    // Remove any spaces after colon:
    if (parent.get(i + 1).is(&#x27;space&#x27;)) parent.removeChild(i + 1);
    // If the value set in config is not empty, add spaces:
    if (value !== &#x27;&#x27;) {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i + 1, space);
    }

    return null;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_after_combinator" id="apidoc.module.csscomb.space_after_combinator">module csscomb.space_after_combinator</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_after_combinator.detect" id="apidoc.element.csscomb.space_after_combinator.detect">
        function <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;combinator&#x27;, function (combinator, i, parent) {
    if (parent.get(i + 1).is(&#x27;space&#x27;)) {
      detected.push(parent.get(i + 1).content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_after_combinator.process" id="apidoc.element.csscomb.space_after_combinator.process">
        function <span class="apidocSignatureSpan">csscomb.space_after_combinator.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;combinator&#x27;, function (combinator, i, parent) {
    if (parent.get(i + 1).is(&#x27;space&#x27;)) {
      parent.get(i + 1).content = value;
    } else {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i + 1, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_after_opening_brace" id="apidoc.module.csscomb.space_after_opening_brace">module csscomb.space_after_opening_brace</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_after_opening_brace.detect" id="apidoc.element.csscomb.space_after_opening_brace.detect">
        function <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverse(function (node) {
    if (!node.is(&#x27;block&#x27;) &#x26;&#x26; !node.is(&#x27;atrulers&#x27;)) return;

    if (node.first().is(&#x27;space&#x27;)) {
      detected.push(node.first().content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_after_opening_brace.process" id="apidoc.element.csscomb.space_after_opening_brace.process">
        function <span class="apidocSignatureSpan">csscomb.space_after_opening_brace.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverse(function (node) {
    // If found block node stop at the next one for space check
    if (!node.is(&#x27;block&#x27;) &#x26;&#x26; !node.is(&#x27;atrulers&#x27;)) return;

    if (node.first() &#x26;&#x26; node.first().is(&#x27;space&#x27;)) {
      node.first().content = value;
    } else if (value !== &#x27;&#x27;) {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      node.insert(0, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_after_selector_delimiter" id="apidoc.module.csscomb.space_after_selector_delimiter">module csscomb.space_after_selector_delimiter</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_after_selector_delimiter.detect" id="apidoc.element.csscomb.space_after_selector_delimiter.detect">
        function <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;delimiter&#x27;, function (delimiter, i, parent) {
    if (parent.is(&#x27;arguments&#x27;)) return;

    var nextNode = parent.get(i + 1);

    if (nextNode &#x26;&#x26; nextNode.is(&#x27;space&#x27;)) {
      detected.push(nextNode.content);
    } else if (nextNode.first() &#x26;&#x26; nextNode.first().is(&#x27;space&#x27;)) {
      detected.push(nextNode.first().content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_after_selector_delimiter.process" id="apidoc.element.csscomb.space_after_selector_delimiter.process">
        function <span class="apidocSignatureSpan">csscomb.space_after_selector_delimiter.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;delimiter&#x27;, function (delimiter, i, parent) {
    if (parent.is(&#x27;arguments&#x27;)) return;

    var nextNode = parent.get(i + 1);

    if (nextNode.is(&#x27;space&#x27;)) {
      nextNode.content = value;
    } else if (nextNode.first().is(&#x27;space&#x27;)) {
      nextNode.first().content = value;
    } else {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      nextNode.insert(0, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_before_closing_brace" id="apidoc.module.csscomb.space_before_closing_brace">module csscomb.space_before_closing_brace</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_before_closing_brace.detect" id="apidoc.element.csscomb.space_before_closing_brace.detect">
        function <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByTypes([&#x27;block&#x27;, &#x27;atrulers&#x27;], function (node) {
    // For the block node, find its last (the deepest) child
    var whitespaceNode = getLastWhitespaceNode(node);
    if (whitespaceNode) {
      detected.push(whitespaceNode.content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_before_closing_brace.process" id="apidoc.element.csscomb.space_before_closing_brace.process">
        function <span class="apidocSignatureSpan">csscomb.space_before_closing_brace.</span>process
        <span class="apidocSignatureSpan">(ast, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast, config) {
  valueFromSettings = this.value;
  blockIndent = config[&#x27;block-indent&#x27;];

  processBlock(ast);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_before_colon" id="apidoc.module.csscomb.space_before_colon">module csscomb.space_before_colon</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_before_colon.detect" id="apidoc.element.csscomb.space_before_colon.detect">
        function <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;propertyDelimiter&#x27;, function (delimiter, i, parent) {
    if (parent.get(i - 1).is(&#x27;space&#x27;)) {
      detected.push(parent.get(i - 1).content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_before_colon.process" id="apidoc.element.csscomb.space_before_colon.process">
        function <span class="apidocSignatureSpan">csscomb.space_before_colon.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;propertyDelimiter&#x27;, function (delimiter, i, parent) {
    if (delimiter.syntax === &#x27;sass&#x27; &#x26;&#x26; !parent.get(i - 1)) return;

    // Remove any spaces before colon:
    if (parent.get(i - 1).is(&#x27;space&#x27;)) {
      parent.removeChild(--i);
    }

    // If the value set in config is not empty, add spaces:
    if (value !== &#x27;&#x27;) {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_before_combinator" id="apidoc.module.csscomb.space_before_combinator">module csscomb.space_before_combinator</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_before_combinator.detect" id="apidoc.element.csscomb.space_before_combinator.detect">
        function <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;combinator&#x27;, function (combinator, i, parent) {
    if (parent.get(i - 1).is(&#x27;space&#x27;)) {
      detected.push(parent.get(i - 1).content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_before_combinator.process" id="apidoc.element.csscomb.space_before_combinator.process">
        function <span class="apidocSignatureSpan">csscomb.space_before_combinator.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;combinator&#x27;, function (combinator, i, parent) {
    if (parent.get(i - 1).is(&#x27;space&#x27;)) {
      parent.get(i - 1).content = value;
    } else {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_before_opening_brace" id="apidoc.module.csscomb.space_before_opening_brace">module csscomb.space_before_opening_brace</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_before_opening_brace.detect" id="apidoc.element.csscomb.space_before_opening_brace.detect">
        function <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  var detected = [];

  ast.traverseByTypes([&#x27;block&#x27;, &#x27;value&#x27;], function (block, i, parent) {
    if (block.is(&#x27;value&#x27;) &#x26;&#x26; !block.first().is(&#x27;block&#x27;)) return;

    var previousNode = parent.get(i - 1);
    if (!previousNode) return;

    // If it&#x27;s spaces, modify this node.
    // If it&#x27;s something different from spaces, add a space node to
    // the end:
    if (previousNode.is(&#x27;space&#x27;)) {
      detected.push(previousNode.content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_before_opening_brace.process" id="apidoc.element.csscomb.space_before_opening_brace.process">
        function <span class="apidocSignatureSpan">csscomb.space_before_opening_brace.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  // If found block node stop at the next one for space check.
  ast.traverseByTypes([&#x27;block&#x27;, &#x27;value&#x27;], function (block, i, parent) {
    if (block.is(&#x27;value&#x27;) &#x26;&#x26; !block.first().is(&#x27;block&#x27;)) return;

    var previousNode = parent.get(i - 1);
    if (!previousNode) return;

    // If it&#x27;s spaces, modify this node.
    // If it&#x27;s something different from spaces, add a space node to
    // the end:
    if (previousNode.is(&#x27;space&#x27;)) {
      previousNode.content = value;
    } else if (value !== &#x27;&#x27;) {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_before_selector_delimiter" id="apidoc.module.csscomb.space_before_selector_delimiter">module csscomb.space_before_selector_delimiter</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_before_selector_delimiter.detect" id="apidoc.element.csscomb.space_before_selector_delimiter.detect">
        function <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverseByType(&#x27;delimiter&#x27;, function (delimiter, i, parent) {
    if (parent.is(&#x27;arguments&#x27;)) return;

    var previousNode = parent.get(i - 1);
    if (previousNode.is(&#x27;space&#x27;)) {
      detected.push(previousNode.content);
    } else {
      detected.push(&#x27;&#x27;);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.space_before_selector_delimiter.process" id="apidoc.element.csscomb.space_before_selector_delimiter.process">
        function <span class="apidocSignatureSpan">csscomb.space_before_selector_delimiter.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;delimiter&#x27;, function (delimiter, i, parent) {
    if (parent.is(&#x27;arguments&#x27;)) return;

    var previousNode = parent.get(i - 1);
    if (previousNode.is(&#x27;space&#x27;)) {
      previousNode.content = value;
    } else {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.space_between_declarations" id="apidoc.module.csscomb.space_between_declarations">module csscomb.space_between_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.space_between_declarations.process" id="apidoc.element.csscomb.space_between_declarations.process">
        function <span class="apidocSignatureSpan">csscomb.space_between_declarations.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;declarationDelimiter&#x27;, (delimiter, i, parent) =&#x3e; {
    // Grom user&#x27;s point of view &#x22;declaration&#x22; includes semicolons
    // and comments placed on the same line.
    // So group those things together:
    var declarationEnd = getDeclarationEnd(parent, i);
    if (!declarationEnd) {
      return;
    } else {
      i = declarationEnd;
    }

    var nextNode = parent.get(i + 1);
    if (nextNode.is(&#x27;space&#x27;)) {
      nextNode.content = value;
    } else {
      var space = gonzales.createNode({
        type: &#x27;space&#x27;,
        content: value
      });
      parent.insert(i + 1, space);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.strip_spaces" id="apidoc.module.csscomb.strip_spaces">module csscomb.strip_spaces</a></h1>




    <h2>
        <a href="#apidoc.element.csscomb.strip_spaces.detect" id="apidoc.element.csscomb.strip_spaces.detect">
        function <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  var lastChild = ast.last();
  if (lastChild.is(&#x27;space&#x27;) &#x26;&#x26; lastChild.content !== &#x27;\n&#x27; &#x26;&#x26; lastChild.content.match(/^[ \n\t]+$/)) {
    detected.push(false);
  }

  ast.traverseByType(&#x27;space&#x27;, function (space) {
    if (space.content.match(/[ \t]\n/)) detected.push(false);
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.strip_spaces.process" id="apidoc.element.csscomb.strip_spaces.process">
        function <span class="apidocSignatureSpan">csscomb.strip_spaces.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  var lastChild = ast.last();
  if (lastChild.is(&#x27;space&#x27;)) {
    lastChild.content = trim(lastChild.content).replace(/[ \t]+$/, &#x27;&#x27;).replace(/[\n]+/g, &#x27;\n&#x27;);
  }

  ast.traverseByType(&#x27;space&#x27;, function (space) {
    space.content = trim(space.content);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.tab_size" id="apidoc.module.csscomb.tab_size">module csscomb.tab_size</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.tab_size.process" id="apidoc.element.csscomb.tab_size.process">
        function <span class="apidocSignatureSpan">csscomb.tab_size.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  let value = this.value;

  ast.traverseByType(&#x27;space&#x27;, function (space) {
    space.content = space.content.replace(/\t/, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csscomb.unitless_zero" id="apidoc.module.csscomb.unitless_zero">module csscomb.unitless_zero</a></h1>


    <h2>
        <a href="#apidoc.element.csscomb.unitless_zero.detect" id="apidoc.element.csscomb.unitless_zero.detect">
        function <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>detect
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (ast) {
  let detected = [];

  ast.traverse(function (node, index, parent) {
    // If we see a zero with unit and it is not degree,
    // then we dont have an option
    if (node.is(&#x27;percentage&#x27;) &#x26;&#x26; node.first(&#x27;number&#x27;).content[1] === &#x27;0&#x27;) {
      detected.push(false);
      return;
    }

    if (node.is(&#x27;dimension&#x27;) &#x26;&#x26; node.first(&#x27;number&#x27;).content === &#x27;0&#x27; &#x26;&#x26; node.first(&#x27;ident&#x27;).content !== &#x27;deg&#x27;) {
      detected.push(false);
      return;
    }

    // If we see a zero and previous node is not percentage
    // or dimension, then we have an option
    if (node.is(&#x27;number&#x27;) &#x26;&#x26; node.content === &#x27;0&#x27; &#x26;&#x26; !parent.is(&#x27;percentage&#x27;) &#x26;&#x26; !parent.is(&#x27;dimension&#x27;)) {
      detected.push(true);
    }
  });

  return detected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csscomb.unitless_zero.process" id="apidoc.element.csscomb.unitless_zero.process">
        function <span class="apidocSignatureSpan">csscomb.unitless_zero.</span>process
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (ast) {
  var UNITS = [&#x27;cm&#x27;, &#x27;em&#x27;, &#x27;ex&#x27;, &#x27;pt&#x27;, &#x27;px&#x27;];

  ast.traverseByTypes([&#x27;value&#x27;, &#x27;parentheses&#x27;], function (node) {
    node.forEach(function (value) {
      if (typeof value === &#x27;string&#x27;) return;

      if (value.is(&#x27;dimension&#x27;)) {
        var unit = value.first(&#x27;ident&#x27;).content;
        if (value.first(&#x27;number&#x27;).content === &#x27;0&#x27; &#x26;&#x26; UNITS.indexOf(unit) !== -1) {
          value.removeChild(1);
        }
      } else if (value.is(&#x27;percentage&#x27;)) {
        var number = value.first(&#x27;number&#x27;).content;
        if (number === &#x27;0&#x27;) {
          value.type = &#x27;number&#x27;;
          value.content = number;
        }
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
_processTree(ast) {
  let config = this.config;

  this.plugins.filter(function (plugin) {
    return plugin.value !== null &#x26;&#x26; typeof plugin.process === &#x27;function&#x27; &#x26;&#x26; plugin.syntax.indexOf(
ast.syntax) !== -1;
  }).forEach(function (plugin) {
    plugin.<span class="apidocCodeKeywordSpan">process</span>(ast, config);
  });

  return ast;
}

_readFile(path) {
  return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>








</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
